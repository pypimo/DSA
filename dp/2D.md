## Cherry pickup (two robots A and B)
```cpp
class Solution {
public:
    int cherryPickup(vector<vector<int>>& grid) {
        int rows = grid.size(), cols=grid[0].size(), ans=0;
        int dp[80][80][80];
        memset(dp, -1, sizeof(dp));

        dp[0][0][cols-1] = grid[0][0];
        if (cols>1) dp[0][0][cols-1] += grid[0][cols-1];
        
        
        for (int i=1; i<rows; i++) {
            for (int c1=0; c1<cols; c1++) {
                for (int c2=0; c2<cols; c2++) {
                    
                    int maxi=INT_MIN;
                    for (int d1=-1; d1<=1; d1++) {
                        for (int d2=-1; d2<=1; d2++) {
                            if (c1+d1<0 || c1+d1>=cols || c2+d2<0 || c2+d2>=cols || dp[i-1][c1+d1][c2+d2]==-1) continue;
                            maxi=max(maxi, dp[i-1][c1+d1][c2+d2]);
                        }
                    }
                    
                    if (maxi==INT_MIN) continue;
                   
                    dp[i][c1][c2] = grid[i][c1];
                    if (c1!=c2) dp[i][c1][c2] += grid[i][c2];
                    dp[i][c1][c2]+=maxi;
                }
            }
        }
   
        for (int c1=0; c1<cols; c1++) {
            for (int c2=0; c2<cols; c2++) {
                ans = max(ans, dp[rows-1][c1][c2]);
            }
        }
        return ans;
    }
};
```
## Stste Compression

https://leetcode.com/problems/painting-a-grid-with-three-different-colors
- cell level dp is too naive, because you can't use `sum` or `max` of any combinations without seeing the path history
- the adjacency constraints affect whole rows and columns
- instead make a validCol that stores col patterns that are valid
- then for each col, check the previous col patterns and add
```cpp
class Solution {
public:
    int m = 1e9+7;
    bool compare(vector<int>& a, vector<int>& b) {
        for (int ind=0; ind<a.size(); ind++) {
            if (a[ind]==b[ind]) return false;
        }
        return true;
    }
    int add(int a, int b){
        return (a+b)%m;
    }
    int colorTheGrid(int m, int n) {
        vector<vector<int>> validCol;
        for (int i=0; i<pow(3,m); i++) {
            int num=i, flag=1;
            vector<int> col;
            for (int j=0; j<m; j++) {
                col.push_back(num%3);
                num/=3;
                if (j && col[j]==col[j-1]) {
                    flag=0;
                    break;
                } 
            }
            if (flag) validCol.push_back(col);
        }
        int cols = validCol.size();
        vector<vector<int>> dp(n,vector<int>(cols,0));
        for (int j=0; j<cols; j++) {
            dp[0][j] = 1;
        }
        for (int i=1; i<n; i++) {
            for (int j=0; j<cols; j++) {
                for (int k=0; k<cols; k++) {
                    if (compare(validCol[j], validCol[k])) dp[i][j]=add(dp[i][j], dp[i-1][k]);
                }
            }
        }

        int sum=0;
        for (int j=0; j<cols; j++) sum=add(sum, dp[n-1][j]);
        return sum;
    }
};
``` 
## Max operations on subarray with SUM 
https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-ii/description/
- can remove numbers either 2 from front, or 2 from back, or 1 front 1 back
- issue is even if all 3 above are possible, removing will change array, so need to take max of operation on remaining subarray, which can further have above 3 ways of num removal
- dp[l][r] contains max operations of subarray [l...r]
```cpp
  int maxOperations(vector<int>& nums) {
        int n = nums.size(),ans=0;
        if (n==1) return 0;
        vector<int> sums={nums[0]+nums[1], nums[n-1]+nums[n-2], nums[0]+nums[n-1]};
        for (int sum:sums) {
            vector<vector<int>> dp(n,vector<int>(n,0));
            for (int i=n-2; i>=0; i--) {
                for (int j=i+1; j<n; j++) {
                    int ct=0;
                    if (j-i+1==2) {
                        if (nums[i]+nums[j]==sum) ct=1;
                        dp[i][j]=ct;
                        continue;
                    }
                    if (i+2<=j && nums[i]+nums[i+1]==sum) ct=max(ct,dp[i+2][j]+1);
                    if (j-2>=i && nums[j]+nums[j-1]==sum) ct=max(ct,dp[i][j-2]+1);
                    if (i+1<=j-1 && nums[i]+nums[j]==sum) ct=max(ct,dp[i+1][j-1]+1);
                    dp[i][j]=ct;
                   
                }
            }
            ans=max(dp[0][n-1], ans);
        }
        return ans;
    }
  ```
